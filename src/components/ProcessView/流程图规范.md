图节点数据结构如下：

```ts
interface Node {
  id: string
  visible: boolean
  relativeDuty: string
  status: string
  prevNodes: string[]
  nextNodes: string[]
}
```

生成展示用流程图流程如下：
- 走确定隐藏节点处理流程
  - 根据相关职责 + 需求中参与的角色确定哪些节点被隐藏
- 得到完整流程图，但是部分节点携带隐藏标记
- 从图的终点向前遍历
  - 行为参考节点被隐藏部分

当一个节点被隐藏：
- 他被视为已完成
- 他的后继节点向前查找1层节点
  - 如果已有与之相连的前继节点，则断开与隐藏节点的联系（继续保持未完成节点的连接，即开启节点的前置任务依然未完成）
  - 否则一直向前查找，直到找到所有可连接节点（前置任务都完成了，那就向前找所有未完成的任务）

当一个节点流转为已完成：
- 他的所有后置节点检查所有的前置节点，如果均完成了，则流转为进行中

当一个节点被重新展示：
- 流程状态不变
- 已完成节点可以通过回滚转变为未开始

当一个节点发生回滚：
- 其所有后置节点均回滚为未开始


# 曲线绘制规范

## 单个区间内的连线

绘图中的边可以分解为左侧n个输入，右侧m个输出，现在需要用贝塞尔曲线将其连接，并针对每条线不同的起终点给出不同的样式，现在的问题是如何找到这个样式

对每个线给定一个id：`${左侧点总数}-${当前边左侧点起点序号}-${右侧点总数}-${右侧点终点序号}`

通过这样一个id，我们可以描述出任何一条线在一个区间内的所在位置

现需要一个函数计算计算出每个不同连接点相关的贝塞尔曲率

### 节点左右侧单双数的影响

分两种情况：
- 左侧为单数或双数，右侧则相反为双数或者单数
- 两侧都为单数或双数

第一种情况则会导致两边都对不齐，需要一个算法处理不对齐的曲率计算

- 调用curveCaleWithoutAlign(left, right)，返回样式

第二种则会有n个节点可以在水平上对齐 (n=min(n,m))，这里采用另一种曲率计算实现

第二种情况的算法：
- 零左侧点总数leftTotal，当前边左侧点起点序号leftIndex，右侧点总数rightTotal，右侧点终点序号rightIndex
- 如果 leftTotal === rightTotal && leftIndex === rightIndex
  - 返回空样式，代表直线
- 计算开始对齐的索引 startAlignIndex = Math.abs(leftTotal - rightTotal) / 2
- 如果 leftTotal < rightTotal
  - 如果 leftIndex === rightIndex - startAlignIndex，则代表他们平行，返回空样式
- 如果 leftTotal > rightTotal
  - 如果 leftIndex - startAlignIndex === rightIndex，则代表他们平行，返回空样式
- 调用curveCaleWithAlign(left, right)，返回样式

曲率函数的主要作用是返回一条贝塞尔曲线，他越靠近节点就越平行于水平线。

### 边 id 如何计算

#### 相邻区间内的点计算

然后是计算一个节点处在一个区间内的什么位置，与谁相连，这样就可以把需要的边给计算出来
方法是建立一个点的 xy 表，key 为 x， value 为 y[]，即该水平线上垂直方向的点的数组，且该数组有序
最后就是遍历每一个区间，并计算区间内需要相连的两点的边，为边设置其对应的样式

## 跨区间连线


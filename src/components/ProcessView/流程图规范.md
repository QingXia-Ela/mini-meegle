图节点数据结构如下：

```ts
interface Node {
  id: string
  visible: boolean
  relativeDuty: string
  status: string
  prevNodes: string[]
  nextNodes: string[]
}
```

生成展示用流程图流程如下：
- 走确定隐藏节点处理流程
  - 根据相关职责 + 需求中参与的角色确定哪些节点被隐藏
- 得到完整流程图，但是部分节点携带隐藏标记
- 从图的终点向前遍历
  - 行为参考节点被隐藏部分

当一个节点被隐藏：
- 他被视为已完成
- 他的后继节点向前查找1层节点
  - 如果已有与之相连的前继节点，则断开与隐藏节点的联系（继续保持未完成节点的连接，即开启节点的前置任务依然未完成）
  - 否则一直向前查找，直到找到所有可连接节点（前置任务都完成了，那就向前找所有未完成的任务）

当一个节点流转为已完成：
- 他的所有后置节点检查所有的前置节点，如果均完成了，则流转为进行中

当一个节点被重新展示：
- 流程状态不变
- 已完成节点可以通过回滚转变为未开始

当一个节点发生回滚：
- 其所有后置节点均回滚为未开始


# 曲线绘制规范

## 单个区间内的连线

绘图中的边可以分解为左侧n个输入，右侧m个输出，现在需要用贝塞尔曲线将其连接，并针对每条线不同的起终点给出不同的样式，现在的问题是如何找到这个样式

对每个线给定一个id：`${左侧点总数}-${当前边左侧点起点序号}-${右侧点总数}-${右侧点终点序号}`

通过这样一个id，我们可以描述出任何一条线在一个区间内的所在位置

现需要一个函数计算计算出每个不同连接点相关的贝塞尔曲率

### 节点左右侧单双数的影响

分两种情况：
- 左侧为单数或双数，右侧则相反为双数或者单数
- 两侧都为单数或双数

第一种情况则会导致两边都对不齐，需要一个算法处理不对齐的曲率计算

- 调用curveCaleWithoutAlign(left, right)，返回样式

第二种则会有n个节点可以在水平上对齐 (n=min(n,m))，这里采用另一种曲率计算实现

第二种情况的算法：
- 零左侧点总数leftTotal，当前边左侧点起点序号leftIndex，右侧点总数rightTotal，右侧点终点序号rightIndex
- 如果 leftTotal === rightTotal && leftIndex === rightIndex
  - 返回空样式，代表直线
- 计算开始对齐的索引 startAlignIndex = Math.abs(leftTotal - rightTotal) / 2
- 如果 leftTotal < rightTotal
  - 如果 leftIndex === rightIndex - startAlignIndex，则代表他们平行，返回空样式
- 如果 leftTotal > rightTotal
  - 如果 leftIndex - startAlignIndex === rightIndex，则代表他们平行，返回空样式
- 调用curveCaleWithAlign(left, right)，返回样式

曲率函数的主要作用是返回一条贝塞尔曲线，他越靠近节点就越平行于水平线。

### 边 id 如何计算

#### 相邻区间内的点计算

然后是计算一个节点处在一个区间内的什么位置，与谁相连，这样就可以把需要的边给计算出来
方法是建立一个点的 xy 表，key 为 x， value 为 y[]，即该水平线上垂直方向的点的数组，且该数组有序
最后就是遍历每一个区间，并计算区间内需要相连的两点的边，为边设置其对应的样式

## 跨区间连线

跨区间连线用于解决两点之间不是相邻，但存在连接关系的情况

### 该如何将两个节点连起来才好看，且可以贴合流程图现有代码实现

目前我们将节点以列的形式分为一层一层的样子，从左到右为流程开始到结束，跨层连线出现时，我们可以在跨过的层的上方或者下方增加一个虚拟节点，该节点仅仅用来做连线展示，不具备任何功能

#### 虚拟节点相关数据结构

id 结构：`${第n层}-${up/down}-${终点id[]}-${randomID}`

`终点id[]` 为 `id$id$id` 的形式

```ts
type ProcessDummyNodeIdType = string

interface ProcessDummyNodeType {
  type: "dummy_list",
  id: string
  prevNodes: (ProcessNodeIdType | ProcessDummyNodeIdType)[]
  nextNodes: (ProcessNodeIdType | ProcessDummyNodeIdType)[]
  [key: string]: any
}
```

#### 节点冗余

该设计在出现大量节点需要跨区间连接时会在同一层上添加多个节点，目前针对该问题会从以下方面进行节点复用合并：
- 多个不同起点存在相同终点时，他们会复用该路径上相同的虚拟连线节点
  - 相同终点指的是多个起点存在完全相同的终点（不包括包含与被包含关系）
- 如何保证节点尽可能地达到复用效果
  - 对所有存在相同终点的边进行排序，排序依据为按跨过的层数降序排序，并从头开始遍历与处理边，这样在以下情况可以做到同终点情况下完全复用已有节点
  - 此处需要根据上下位置进行分别计算
- 如何让连接多个终点的边尽可能靠近图节点保证美观
  - 生成完所有的虚拟节点后，对每一层的上下所有虚拟节点进行排序，上层节点则按终点数量进行升序排序，下层则降序
    - 如果终点数量相同，则按照起终点高低差排序，高低差越低则越靠近图

#### 该在层的上方还是下方添加虚拟节点

这取决于起终点位置：
- 如果起点在 y 轴上比终点高，则走上方
- 否则走下方

这种方式存在一个问题（不影响使用，只影响观感）：
- 处在流程图中间的节点如果要跨区间连线时，不会选择走节点之间的空隙连接，而是走图的最外围去进行连线

### 总结与落实方案

- 遍历图，找出`所有的边`，并将其列为一个集合
- 遍历区间，找出`所有区间内的边`，减去`所有的边`，得到`所有跨区间的边列表`
- 遍历`所有跨区间的边列表`，并创建一个 `终点映射虚拟节点` Map，key 为终点数组，value 为虚拟节点数组
- 排序`所有跨区间的边列表`，根据边所跨越的区间数量进行降序排序，如果跨越区间数量相同则根据终点数量排序降序排序，最后根据起终点 y 高低差排序，越低则排越前，终点 y 由终点所有节点 y 的平均值得出。（这一步可以提前把同一个终点的所有边中的最大长度边生成出来，后续添加同一终点的边时全部的边均可复用已有节点，以此达到最大复用率）
- 定义 `任意起点连接的所有终点` Map，key 为起点 id，value 为 终点id 数组
- 遍历`任意起点连接的所有终点`，其中
  - 从 `终点映射虚拟节点` 查询虚拟节点数组
    - 调用 `为图根据边生成虚拟节点` 方法，根据返回结果添加到 `终点映射虚拟节点` Map
    - 调用 `为图添加虚拟节点`，更新图

- 定义 `为图根据边生成虚拟节点` 方法，接受 `图`、`起点`、`终点数组`、`终点映射虚拟节点`，返回 `虚拟节点数组`
  - 计算终点平均 y
  - 根据起点 y 和终点 y 确定 `up` `down` 并赋值给 `direction`
  - 定义 `虚拟节点` Map，`key` 为层数，`value` 为连线时经过该层的终点id
  - 对每个终点枚举，遍历其从起点到终点所经过的层，并修改 `虚拟节点` Map 将终点 id 添加进层对应的 value 中
  - 遍历 `虚拟节点` Map，生成对应完整虚拟节点，并将其根据关系进行连接（包含与起终点的连接）
  - 返回 `虚拟节点数组`
- 定义 `为图添加虚拟节点` 方法，接受 `图`、`虚拟节点数组`，并返回修改后的图
